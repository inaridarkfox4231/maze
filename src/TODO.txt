// TODO
// 余計なコードの削除
// トーラス構造でのテスト
// 線の装飾や背景はどうするか
// オフセットは機能しているのか（大きなサイズでもきちんと動くのか）
// 各種アイコン、プレイヤーの表示
// あと挙動が若干不自然なのをどう解消するのか
// などなど

// 徘徊オブジェクトの仕様
// どっかの頂点に出現
// どっかの辺に乗る
// 辺から辺へ
// 頂点では基本的にいずれか選んで移動、来た方向以外で。
// 行けない場合に引き返す。
// プレイヤーの移動ルーチンと違ってdirectionが出てこない（選択肢から選ぶだけ）ので楽だと思う
// 移動スピードで個性を出せる感じ
// そこまでできたらなんか出させる。攻撃っぽい何か。
// こちらも攻撃っぽい何かを出せるようにする
// 当たる仕様まで作るならHPとかダメージ量とかも必要になりそう・・

// まず頂点について、ゴールまでの最短ルート上の頂点というのはゴールまで行く場合すべて必ず通ることになってる
// どこを通行不能にしてもたどり着けない
// だからたとえばどっかにカギをおいてそれで扉を開けさせることも可能
// valueについてはvalueが大きいマスはそれよりvalueが小さいマスより先には到達出来ないから
// 最短ルート上のどっかのマスを不能にしてそこを開けるカギをそれよりvalueの小さいマスにランダムに置いてもまったく問題ない
// ただたいていの場合ルート上に置かれちゃうのがまずいところ（まあそれは仕方ないのだけど・・）
// フラグでonRoute=true/falseでonRouteでかつvalueがgoalの1割～9割のマスにフラッグを置きたいのよね.
// オリエンテーリングでよくあるあれ
// スタートは赤フラッグ（文字S）、ゴールは紫フラッグ（文字G）
// やめ
// 32x32をくるくる、でいいのでは。
// 四角形に(32,0)→(0,32)の線を引いてその下が色で上が文字。裏は灰色、これがくるくるする。OK!
// 同時にふんわり浮かせる（やや高めの所をsinで小さくふわふわ）
// って思ったけどよく考えたらonRouteに置いちゃったらヒントになってしまうので
// まあ別にいいか
// onRouteの1割~9割に置く！
// 3%～7%の頂点からランダムチョイスしてどっかにカギ置いてそれ取らないと空かないようにしたら面白そう
// いいや・・・はやくフラッグ置こう

// onRouteできました(疲れた・・・）
// フラッグ立てたよ。立てたけど・・onRoute要らんやんな・・
// なんかの役には立つだろうから残しといて（（（

// オブジェクトがへんなとこ移動してる
// どうもフロアの切り替えで失敗してるっぽい→直した

// 次は
// まあゆくゆくはポイント初めて通過した時の効果音とかゴール着いたら次のステージとかそもそもステージ選択とか
// いろいろ斜めの辺とかもあるけど作りたいけど
// また今度ね

// プレイヤーがどこにいるのかわかりにくいからなんか周囲を円がくるくるまわるとかでわかりやすくしてビジュアルはかわいいのお願い
// 攻撃はマウスダウンからリリースまでの時間で3種類（マウスの方向に1発、マウスの方向含めて4方向に1発ずつ、マウスの方向にレーザー1発）
// レーザーはスリップダメージだけどほかの弾丸は当たると消える
// ライフゲージを表示してわかりやすく（プレイヤーも）敵は赤でこっちは青
// そんな感じ
// 弾丸は個別にクラス用意して

// 考えた。
// まずスペースクラス
// これには640x480（表示エリア）と迷路のサイズ（w*GRIDxh*GRID的なやつ！）が入ってて
// これを表示するオブジェクトに持たせる
// これを使って自前でオフセットを計算する感じ
// で、その中にプレイヤーの存在フロアの情報も入ってるわけね
// それを参照して描画するかどうか決めるわけ
// それをやったうえでプレイヤー・・のビジュアルはおいといて、周囲を3つくらい楕円用意してそのまわりに赤青緑の円をまわす
// 楕円軌道だけ。・・地味だからキューブ回そうかな・・
// 能力強化でキューブ増やす（4つまで）
// 攻撃はクリックからリリースまでの・・表現方法はおいおい考える、あのあれ、プレイヤーがどこにいるのかわかりづらいっていうね。
// それをなんとかしないと、スタートの段階でつまづいちゃうので。
// リリースまでの時間で3段階。
// レベル1:カーソルの方向に直進弾。グレードアップで一度に出る弾の数とダメージと弾の大きさが上がる
// 直進弾でスピードは一定
// レベル2:いわゆる3WAYで、同じ方向に3つ並んで発射される感じ。
// 挙動はゆっくりからのぎゅーんって感じで途中から一定スピード
// 弾の形状は矢のようで当たり判定は線分で取る。矢の頭があたるとダメージ大きいけど柄でもダメージ。
// レベルが上がると大きさと本数とダメージが以下略。
// レベル3:レーザー。マウス方向に距離無限大の帯が出現しゆっくり最大幅まで広がってから幅が短くなって消える。
// マウスを動かすとその間常に帯が移動するすぐれもの
// レベルが上がるとダメージや帯の太さや効果時間が上がる感じですかね
// できるの？？？？
// とりあえずホーミングは考えなくていいです

// トレジャーについて
// 次数を用意する（辺の数）
// onRouteでない頂点で次数1でなおかつonRouteの頂点からの距離（戻す処理を何回やるとonRouteにたどり着くか、
// たどり着いた先のonRouteの頂点のvalueと比べて差を取ればいい感じだけどよく考えたらその回数で出るか）
// まあいいや。で、その値。jsのsortを使う。比較関数で(a,b)=>a.x-b.xってやるとプロパティxを見てそれが
// 小さい順に並ぶ、逆にすると大きい順。だからindexとその値のペアを作って・・
// 逐次更新の方が速いですね・・配列作るのは普通に手間だ、やめよう・・・
// onRouteならスルー、次数2以上ならスルー、次数1でonRouteでなければ処理をやってonRouteまで行く、その際の
// 回数を数えて大きければthis.treasureを更新する、って感じですかね。

// あーーーーむずい。どうしようかね
// いったん、パス。

// 空間情報（オフセットの計算に使う）
/*
class Space{
  constructor(dw, dh){
    this.displaySize = {w:dw, h:dh};
    this.floorSize = {};
    this.currentFloorIndex = 0;
    this.playerPos = undefined; // playerのpositionがオブジェクトなのでそこへのポインタを渡しておく
    this.offSet = {}; // オフセット
  }
  setPlayerPos(_playerPos){
    this.playerPos = _playerPos;
  }
  setFloorSize(fw, fh){
    this.floorSize.w = fw;
    this.floorSize.h = fh;
  }
  setCurrentFloorIndex(){
    this.currentFloorIndex = this.playerPos.z;
  }
  getCurrentFloorIndex(){
    return this.currentFloorIndex;
  }
  setOffSet(){
    this.offSet.x = constrain(this.playerPos.x * GRID - this.displaySize.w * 0.5, 0, this.floorSize.w - this.displaySize.w);
    this.offSet.y = constrain(this.playerPos.y * GRID - this.displaySize.h * 0.5, 0, this.floorSize.h - this.displaySize.h);
  }
  getOffSet(){
    return this.offSet;
  }
  getDrawPos(p){
    // pは描画するそれのポジション。
    // p.zとplayerPos.zを比較すればいろいろわかっちゃうね・・となるとあそこの処理不要だな。
    // って思ったけどそれないと選べないしキャンバスが。
    if(p.z !== this.playerPos.z){ return undefined; }
    return {x:p.x * GRID - this.offSet.x, y:p.y * GRID - this.offSet.y};
  }
  update(){
    this.setCurrentFloorIndex();
    this.setOffSet();
  }
}
*/
