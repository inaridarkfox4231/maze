// TODO
// 余計なコードの削除
// トーラス構造でのテスト
// 線の装飾や背景はどうするか
// オフセットは機能しているのか（大きなサイズでもきちんと動くのか）
// 各種アイコン、プレイヤーの表示
// あと挙動が若干不自然なのをどう解消するのか
// などなど

// 徘徊オブジェクトの仕様
// どっかの頂点に出現
// どっかの辺に乗る
// 辺から辺へ
// 頂点では基本的にいずれか選んで移動、来た方向以外で。
// 行けない場合に引き返す。
// プレイヤーの移動ルーチンと違ってdirectionが出てこない（選択肢から選ぶだけ）ので楽だと思う
// 移動スピードで個性を出せる感じ
// そこまでできたらなんか出させる。攻撃っぽい何か。
// こちらも攻撃っぽい何かを出せるようにする
// 当たる仕様まで作るならHPとかダメージ量とかも必要になりそう・・

// まず頂点について、ゴールまでの最短ルート上の頂点というのはゴールまで行く場合すべて必ず通ることになってる
// どこを通行不能にしてもたどり着けない
// だからたとえばどっかにカギをおいてそれで扉を開けさせることも可能
// valueについてはvalueが大きいマスはそれよりvalueが小さいマスより先には到達出来ないから
// 最短ルート上のどっかのマスを不能にしてそこを開けるカギをそれよりvalueの小さいマスにランダムに置いてもまったく問題ない
// ただたいていの場合ルート上に置かれちゃうのがまずいところ（まあそれは仕方ないのだけど・・）
// フラグでonRoute=true/falseでonRouteでかつvalueがgoalの1割～9割のマスにフラッグを置きたいのよね.
// オリエンテーリングでよくあるあれ
// スタートは赤フラッグ（文字S）、ゴールは紫フラッグ（文字G）
// やめ
// 32x32をくるくる、でいいのでは。
// 四角形に(32,0)→(0,32)の線を引いてその下が色で上が文字。裏は灰色、これがくるくるする。OK!
// 同時にふんわり浮かせる（やや高めの所をsinで小さくふわふわ）
// って思ったけどよく考えたらonRouteに置いちゃったらヒントになってしまうので
// まあ別にいいか
// onRouteの1割~9割に置く！
// 3%～7%の頂点からランダムチョイスしてどっかにカギ置いてそれ取らないと空かないようにしたら面白そう
// いいや・・・はやくフラッグ置こう

// onRouteできました(疲れた・・・）
// フラッグ立てたよ。立てたけど・・onRoute要らんやんな・・
// なんかの役には立つだろうから残しといて（（（

// オブジェクトがへんなとこ移動してる
// どうもフロアの切り替えで失敗してるっぽい→直した

// 次は
// まあゆくゆくはポイント初めて通過した時の効果音とかゴール着いたら次のステージとかそもそもステージ選択とか
// いろいろ斜めの辺とかもあるけど作りたいけど
// また今度ね

// プレイヤーがどこにいるのかわかりにくいからなんか周囲を円がくるくるまわるとかでわかりやすくしてビジュアルはかわいいのお願い
// 攻撃はマウスダウンからリリースまでの時間で3種類（マウスの方向に1発、マウスの方向含めて4方向に1発ずつ、マウスの方向にレーザー1発）
// レーザーはスリップダメージだけどほかの弾丸は当たると消える
// ライフゲージを表示してわかりやすく（プレイヤーも）敵は赤でこっちは青
// そんな感じ
// 弾丸は個別にクラス用意して

// 考えた。
// まずスペースクラス
// これには640x480（表示エリア）と迷路のサイズ（w*GRIDxh*GRID的なやつ！）が入ってて
// これを表示するオブジェクトに持たせる
// これを使って自前でオフセットを計算する感じ
// で、その中にプレイヤーの存在フロアの情報も入ってるわけね
// それを参照して描画するかどうか決めるわけ
// それをやったうえでプレイヤー・・のビジュアルはおいといて、周囲を3つくらい楕円用意してそのまわりに赤青緑の円をまわす
// 楕円軌道だけ。・・地味だからキューブ回そうかな・・
// 能力強化でキューブ増やす（4つまで）
// 攻撃はクリックからリリースまでの・・表現方法はおいおい考える、あのあれ、プレイヤーがどこにいるのかわかりづらいっていうね。
// それをなんとかしないと、スタートの段階でつまづいちゃうので。
// リリースまでの時間で3段階。
// レベル1:カーソルの方向に直進弾。グレードアップで一度に出る弾の数とダメージと弾の大きさが上がる
// 直進弾でスピードは一定
// レベル2:いわゆる3WAYで、同じ方向に3つ並んで発射される感じ。
// 挙動はゆっくりからのぎゅーんって感じで途中から一定スピード
// 弾の形状は矢のようで当たり判定は線分で取る。矢の頭があたるとダメージ大きいけど柄でもダメージ。
// レベルが上がると大きさと本数とダメージが以下略。
// レベル3:レーザー。マウス方向に距離無限大の帯が出現しゆっくり最大幅まで広がってから幅が短くなって消える。
// マウスを動かすとその間常に帯が移動するすぐれもの
// レベルが上がるとダメージや帯の太さや効果時間が上がる感じですかね
// できるの？？？？
// とりあえずホーミングは考えなくていいです

// トレジャーについて
// 次数を用意する（辺の数）
// onRouteでない頂点で次数1でなおかつonRouteの頂点からの距離（戻す処理を何回やるとonRouteにたどり着くか、
// たどり着いた先のonRouteの頂点のvalueと比べて差を取ればいい感じだけどよく考えたらその回数で出るか）
// まあいいや。で、その値。jsのsortを使う。比較関数で(a,b)=>a.x-b.xってやるとプロパティxを見てそれが
// 小さい順に並ぶ、逆にすると大きい順。だからindexとその値のペアを作って・・
// 逐次更新の方が速いですね・・配列作るのは普通に手間だ、やめよう・・・
// onRouteならスルー、次数2以上ならスルー、次数1でonRouteでなければ処理をやってonRouteまで行く、その際の
// 回数を数えて大きければthis.treasureを更新する、って感じですかね。

// あーーーーむずい。どうしようかね
// いったん、パス。

// 空間情報（オフセットの計算に使う）
/*
class Space{
  constructor(dw, dh){
    this.displaySize = {w:dw, h:dh};
    this.floorSize = {};
    this.currentFloorIndex = 0;
    this.playerPos = undefined; // playerのpositionがオブジェクトなのでそこへのポインタを渡しておく
    this.offSet = {}; // オフセット
  }
  setPlayerPos(_playerPos){
    this.playerPos = _playerPos;
  }
  setFloorSize(fw, fh){
    this.floorSize.w = fw;
    this.floorSize.h = fh;
  }
  setCurrentFloorIndex(){
    this.currentFloorIndex = this.playerPos.z;
  }
  getCurrentFloorIndex(){
    return this.currentFloorIndex;
  }
  setOffSet(){
    this.offSet.x = constrain(this.playerPos.x * GRID - this.displaySize.w * 0.5, 0, this.floorSize.w - this.displaySize.w);
    this.offSet.y = constrain(this.playerPos.y * GRID - this.displaySize.h * 0.5, 0, this.floorSize.h - this.displaySize.h);
  }
  getOffSet(){
    return this.offSet;
  }
  getDrawPos(p){
    // pは描画するそれのポジション。
    // p.zとplayerPos.zを比較すればいろいろわかっちゃうね・・となるとあそこの処理不要だな。
    // って思ったけどそれないと選べないしキャンバスが。
    if(p.z !== this.playerPos.z){ return undefined; }
    return {x:p.x * GRID - this.offSet.x, y:p.y * GRID - this.offSet.y};
  }
  update(){
    this.setCurrentFloorIndex();
    this.setOffSet();
  }
}
*/

// クラス化してそっちにオフセットもろもろ計算させようとしてたけど却下
// まあオフセットの計算だけならいいんだろうけどね・・
// 一瞬スパゲティになりかけたので戻ってきた
// やばいやばい
// そもそも敵を倒す必要あるの？操作性とかいまいちでイライラしそう。
// いっそ今のまま普通にゴール目指すだけ・・だと面白くないよねぇ。

// 普通にゴール目指すだけでいいよもう

// 迷路の種類増やす
// 攻撃とか敵とかはとりあえずいいとして
// なんかいろいろ攻撃かわして

// 迷路はもういいからSTGに戻りたいかも
// ていうか攻撃で敵倒そうみたいなこと考えちゃうのSTG作りたいから
// だったら堂々とSTGでやればいい
// こっちでやる必要ない
// こっちではギミックかわしながらゴールにたどり着く、でいい
// クリックでキャラクターがジャンプしてとげをかわすとか攻撃よけるとかそういうの
// せっかく敵らしきなにかが動くようになったのにもったいない気もするんだけどね
// 出現場所をランダムでなくフラッグの位置にして、そうすればすぐにぶつからないから、あれをジャンプでかわす？クリックジャンプで？
// あれがかわすべきギミックで？あーなる・・そういうのもありね。
// それと別に砲台かなんか（経路の外に置く）から火の玉かなんかだすとか。

// キャラクターのイメージは暫定的に伸縮する長方形でいいと思う。角を丸くしたmicrobe的な。今んとこあれしかできないので。
// その輪郭でまんじゅうはめて目をつけたり耳をつけたりっていうのを考えてる。
// それか方眼紙に描いて32x32で描いてやるのもありかも

// GRIDを可変にすること
// 32を最小サイズにする
// 32より大きくなる可能性を考える
// フラッグの大きさは32で固定して
// 迷路情報作るときにGRIDの情報を添える
// そうすればたとえば32xsqrt(2)とかもできるはず
// もしくは32にしたうえで別の所をいじってもいいけどめんどくさいでしょ？

// 時間ないのでアイデアだけ
/*
スパボン5でクリアする際に潜り抜けるゴールによって
行先が変わるっていうのあったでしょ
トレジャーに相当する頂点をゴール扱いにして
そこを通ることでその先の迷路の形状がへんかするとか
したら面白そう
パターンチェンジ
それやらないと延々と同じ形状の迷路が続くだけ
っていう話
*/

んーとね。
20x15を最小サイズとしてね・・・その向こうにエリアが存在する場合に、それを表示することで、
スクロールしないようにしようみたいなね。それを今考えてるんだけど計算がめんどくさすぎて萎えてる。。。。
移動に関しては問題ないのです・・その向こうのエリアをプレイヤーの存在する位置から計算するのが大変っていう。

クリックするとジャンプフラグが立って32フレームの間宙に浮く感じで（およそ0.5秒）
その間はダメージを受けないのでとげをかわせる感じ
体ひとつぶん浮く感じでおねがい

その間はp.yが減らされる・・
jumpFlagが出ているときに接触しても・・んー。障害物のグラフィック
例のなんか曲線アートみたいのをくるくるまわ・・
ていうかこれも3Dでなんか作っちゃうとか？
プレイヤーを中心とする640x480に触れるエリアをすべて描画するって感じ
で、それぞれのオフセットと描画範囲を正確に計算する感じ


まずあれ
基本サイズを決めてその中で展開されるみたいな
えーと・・・変更点がいろいろ
たとえば640x480を基本とする場合、これを・・・20x15を最小サイズとしてそれを縦横につなげると。
つまり今までフロアとして扱っていたものをそれぞれ同じサイズに、まあ同じサイズだったけど、
今考えたけどひし形や六角形だとむずいや
上下左右だけ表示されるようにする感じ。
いける？
やめよう
今やりたいのは隣のエリアに行けるときの先が見えない問題をどうにかしようっていうのだからそこどうにかできないとどうしようも
ないので
上下左右だけ！！！
ひし形ならぎりぎりいける。正六角形は辺の向こう側全体で周囲が構成されてしまうので・・螺旋階段作れない
とりあえず20x15でいいです

正方形を基本サイズにしてぐるぐる繋げたら面白そう（実装が鬼）

まず20x15をいくつか用意する
辺のつながりを作る
それにより接続される
接続先は自分自身でもOK（トーラス構造）
新しくその、0,1,2,3で方向をid化したうえで、その方向に何があるのか書いておいて、
プレイヤーがいるエリアの上下左右に部屋があればそれを描画する感じ。スクロールも考慮する。
エリアと同じ枚数のグラフィックを新たに用意する
敵やプレイヤーはそれらに毎フレーム描画する感じですね
んでseparate辺上にいる場合は両方に描画する
これでいいはず

んー今考えてるのは逆に貼り付けるというかそんな感じのあれ
その場合は逆につけますっていうのを・・たとえば4,5,6,7で0,1,2,3の上下反転みたいな？左右反転も？
その場合はグラフィックも左右や上下を反転させたうえで描画しボードに落とすときにも同じように反転させてくっつける感じね
そういうのも面白そうなので考えたりしてる
上下反転、左右反転、180°の回転の4パターンのはりつけの組み合わせとかする感じ
エリアをクラス化してグラフィックとは別に接続状況をidで指示できるようにする
ステージ構成の際にそれを用意して
同じフォーマットなら再利用
違うフォーマットなら破棄して再構成する感じ

クラス、とりあえず640x480のボードとつなぎ方だけでいいですね
ていうかグラフィック再利用できるから
たとえば最初に20枚くらい作っておいて
それ使いまわせばいいやね破棄する必要はない
迷路のグラフィック作成時に
そこに・・

というわけで今floorArrayってなってるとこをareasにする
Areaが20個
んでそれと別に5枚（プレイヤーのエリアと上下左右の合計5枚）
毎フレームの描画はそこにやる
もしかしたらエリアのプロパティを追加して背景色とか具体的な背景指定するかもだけど

// 上下左右でいいんじゃないかな
// 多分だけど
// つまりね、例えばエリアの枚数を32上限として、（32個も用意するの！？しないけど）16でいいです。
// 左右反転の場合は+32,上下反転の場合は+64,上下左右反転の場合は+96ってやれば、
// 32,64のビットを見るだけでそれがどういう風に反転してるかわかる・・
// 31と&取ればフロア数が出るし。
// クラインの四元群だから相対的だし。そういう感じで。

// 16枚で。
// +16:左右反転、+32:上下反転、+48:上下左右反転
// それぞれのエリアに0,1,2,3方向に何があるのか指定しておく
// 何もない場合は-1
// 自分を指定するのもあり(フロア1枚ですべて0とかもありってこと)
// そして各エリアに対しその向こう側のエリアとの接続を行う感じ
// 重複を防ぐためidの小さい方から大きい方のみ行う
// 同じ場合も行う（当然）
// つまりこっちのidが向こうより大きい場合のみスルーするわけね
// それが終わったらいつものようにデータ送信
// そのうえでAreaクラスに情報をいろいろ登録
// 迷路を作り終わったらAreaクラスにベースを描画（暗い灰色で）
// 準備完了
// 毎フレームの処理
// プレイヤー、敵、フラッグそれぞれについて存在するフロアを確認
// バーテックスの場合はいいけど辺の場合はまたがっていれば両方で描画する感じで
// さてさて
// プレイヤーの存在するエリアとその上下左右のエリアがあればそれら、つまり1～5枚
// これらにまずベースの辺を描画
// （なおベースはプレイヤーが乗った辺の色が随時白で更新されていく）
// 次に敵とかフラッグとかが・・
// ちなみにプレイヤーの存在するって言ったけどseparateの場合はprogressをきちんと見て0.5より大きい小さいとか
// きちんと見るのでよろしく
// 特に問題起きないと思うけど
// そうして描画が確定したらそれら一つ一つに描画していく・・
// 反転が起こっている場合は辺の描画の際に反転が起きているのでそれ含めて考慮しつつ
// 敵やら何やらもそれ含めて反転描画する感じですね
// まあすぐには実装しないけど
// プレイヤー自身の存在するエリアが反転起きてる場合それを考慮してひっくり返したりするのでそれ含めて・・ね。
// 正方形の方が自由度高そうでいいな・・そのうちやってみたい。（今やろうよ）
// 自由度が高いとその分大変なので今はやりません（やりません）
// 最後にそれら最大5つを適切にオフセット考慮しつつコラージュして完成。


// mazeConnectingでハマってる
/*
// dirで場合分け。
// dirが0のときはiの右とkの左、dirが1のときはiの下とkの上、dirが2のときはiの左とkの右、dirが3のときはiの上とkの下を
// つなげる
// separateは同じフロアであってももちろんすべてtrueとする感じで
// 同じフロアのトーラス構造であっても・・・んー。一枚に両方・・
// まあそんなことは、起きるね。どうしようね。
// あるオブジェクトをあるフロアに描画するとき、その上下左右に自分と同じフロアがある場合は
// たとえば下に同じフロアがあるとすると当然上にもそのフロアがあるわけ。右なら左。
// だからその場合は
// ていうか辺ベースで描画する？個別の位置ベースじゃなくて。
// つまり存在する辺の情報とプログレス情報を使って描画するようにする
// そうすれば同じフロアの上下左右をつなげる場合でも
// 同じ・・あー、ちがうちがう！
// 頂点ベースで描画する。つまり、辺の両端の頂点を見て、それらの頂点が属する位置ごとに描画する
// separateでない場合は1回しか描画しなくていい
// 同じフロアでseparateの場合はそれぞれの頂点ごとに同じフロアマップに2つ描画する
// 違うフロアでseparateの場合もそれぞれの頂点ごとに違うフロアマップに1つずつ描画する
// 頂点の位置と辺の出てる方向とprogressからフロアごとの描画位置が算出される
// だから各オブジェクトには・・あーそうか、描画オブジェクトには
*/

// 10x8でやるか・・・？
// 10x8でMAX32フロアでやります。つまり最終的には160xやりません
// やりませんが。。
// 40x32だから80x32くらいで最大？64の方がいいかな。10x8が64個。80x64が最大サイズということになるわね。
// 10x8でグリッドサイズ64だから640x512って感じになるね。
// 大幅に書き換えないとだ・・・・でもスライム大きくなるし。わくわく！

// 640x480を640x512にしてGRIDをすべて64にするだけ
// 文字列で書いてあるので変更点は少ないです（よかった・・）
// というわけで帰ったら作業です・・がんば！！！

// このあとやること
// 接続はもう出来てるので今のままあれをあれすると画面が切り替わっちゃう
// とりあえずそれで。
// 接続がうまくいってることを確認したらいよいよグローバルスクロールの実装にとりかかる
// といっても難しくないけどね・・

// むずかしいよ

// 描画順：プレイヤー、敵、その他、最後にフラッグ。そんな感じ。

// 今からやることをまとめます・・・大変です。。。
// とりあえずconstructorと・・3箇所
// drawの中身について
// baseはいじらないよ
// baseの背景設定・・ここでステージの個性を出したいところ
// playerAreaとplayerAroundAreasの最大5つ、まあ4つまでしか表示されないけど、を、置く。
// 作業はn段階(n=4)
// 0:playerAreaとplayerAroundAreasをclear
// 1:playerAreaとplayerAroundAreasで描画に使うものをplayerの存在するフロアの情報から割り出して
//  それらについてareasから辺情報を引っ張ってきて描画する
// （この際反転があればそれを考慮する・・先の話）
// 2:playerAreaとplayerAroundAreasにプレイヤー、敵、オブジェクト、フラッグを配置していく
//  まずこれらのどれかを取るときそのgrを取得してそこに書いていく・・
// フロア番号だけ取得したら以下の処理はすべて同じなのでまとめて書けるはず
// それが存在する辺を調べてその辺がseparateでない場合はその辺が存在するフロア番号が
// カレントと一致なら描画するで終わり
// separateの場合は両端の頂点のフロア番号を見る
// その頂点とプログレスで描画する
// どっちも調べたうえでカレントと一致してる方に描画するので
// 場合によってはカレントの2箇所に描画することもある（同じフロアが連続する場合など）
// このときの描画位置も場合によってずれる可能性があると。
// 3:最後にplayerの存在するフロアの描画位置をプレイヤーのフロアにおける位置情報から計算しbaseに落とす
// Aroundの方は使うものだけbaseに落とす。オフセットはplayerAreaの右下左上だから容易に計算できるよね
// それで。

// 考えたんだけどオフセット使わないならgrを直接あっちに送り込んでOKよね。
// grとそれが存在する番号を送る・・
// areaにフロア番号付与するとか
// phaseも付与するとか？
// playerAreaとplayerAroundAreasをareaで書きたいのです

// 迷路は機能してるけどおそらくオフセット関連がめちゃくちゃ
// ですね

// 今後の方針（ざっくり）
// 今回のあれこれはとりあえずなしで
// 迷路に関しては
// 今の形式でいいよ
// なんかにぎやかしでいろいろ這わせといて
// 攻撃はしない感じで（ただの飾り）
// どうせうまくいかないって知ってた
// 時間の無駄
// でした

// いいところは取り入れる
// 画像の作り方とか
// だからあのエネミーのを放り込んでおいてください
// おわり。

// 15x12をエリアサイズ、ディスプレイは10x8にすれば
// 複数描画する必要はなくなる
// んだけど、位置の計算が謎すぎる
// 配置時の問題は迷路をパッチワークにしてキャラ表示だけ上書きにすれば行けるんだけど
// グローバルの位置計算が謎すぎる
// むりです

// 迷路云々はおいといて、つながりだけぬきだしてテストするとか

// 提案
// 20x16サイズを基本サイズにする（AREA_WIDTHとAREA_HEIGHT）
// で、4x4に分割して、ひとつひとつは5x4なわけだけど。で、隅っこの5x4をはじく。で、
// そこには何も置かない。
// ディスプレイサイズは今まで通り。要するに縮尺で半分ね。
// これならせいぜい二つしか入らないし、常にプレイヤーを中心に置ける。というかもうオフセットめんどくさいから常に真ん中に置きたい。
// プレイヤーも敵もフラッグもそれらの存在する頂点・・
// あー、あれ、プログレスが0.5未満ならfrom側、0.5より大ならto側のフロアにいることにすると。じゃない。
// そっちの・・separateの場合は2回計算する・・で、画面に入る方を採用する
// 1回でも画面に入ったらそれ以降は更新しない。（うそ。普通に画面内に入るたびに更新すればいい。）
// 最初にundefinedなりnullなりで初期化してそれが画面内のどこかにならないならそもそも描画しない
// 条件はDISPLAY±GRID*2でマージン取る。その外側であれば描画しない。
// こうしてグローバルの位置を出してしまいその上でbaseに直接描画する。仲介はもうしない。バグの温床だから。
// 隅っこ移動できちゃうと斜向かいはどうするとか面倒な問題が一気に噴出してしまうのでね・・もうこれで。
// あと提案。通れないところを描画する形式に戻したいのよね。しきいを描画するっていう。で、
// 移動した頂点に対応する床が薄暗い色から濃い色になっていく・・つまり床の画像を用意して、それをくらいのとあかるいのと。
// 明るいのをかわりに置いていく感じですかね・・
// 床の模様で個性を出せたら面白いと思う。
// つまり辺でやっていたことをこれからは頂点でやっていくわけなのね
// 形式はすべて一緒だから周囲（アウトライン）については四隅のところは固定で、接続部分は辺が出てなければ敷居を描画する感じね。

// 1280x1024・・これ最大で16枚？メモリ大丈夫なのか・・

// 流れ
// 迷路の基礎データ作成部分を今の20x16で置き換えて適宜つなぐ
// 貼り合わせ部分もそれに応じて書き換える
// 迷路作成メソッドは特に変更ない。
// playerAreaやらplayerAroundAreaやらは廃止
// area16枚だけ用意する
// draw部分
// まずプレイヤーの位置は中央で固定
// プレイヤーのエリア内での位置に応じてオフセットを計算
// エリア内で右側なら右のエリアがあれば追加、下側で・・って感じで必要なら描画エリアを追加
// さきにこれらをbaseに描いてしまう。baseは背景で初期化してその上にかぶせる。
// プレイヤーや敵に送るのはbase,オフセットの組、フロア番号からなるオブジェクト
// 存在する辺の両端の頂点に対してフロア番号が一致していればオフセットからbase内での位置を出して
// それがDISPLAY±2*GRID内なら位置情報を更新
// 計算前にundefinedにしておき更新されたらbaseに描画する感じ
// プレイヤーは常に中心なのでマウスでの移動は楽ちん
// フラッグも同じ。画面に入らないなら描画しない（グラフィックの作成メソッドも行わない感じで）（つまり位置計算が先ね）

// エリアの描画について
// 辺を描いてたけど、それをやめる。で、最初に壁の所に壁を描画する。太い線か何かで。
// そんで床画像を2種類用意。暗いのと明るいのと。最初はスタートだけ明るく。
// プレイヤーが到達したらその頂点を明るい床で更新していく
// だからそこら辺、壁が消えないように大きさを調節する必要があるわね
// ってそれだと穴が開いちゃうからもう壁と
// そこは背景工夫して
// めんどうなので床を貼り付けてからその頂点からでている通れない辺調べて部分的に壁を再描画してください
// drawWall()
// それでオッケーです









// もうやめよう
