// TODO
// 余計なコードの削除
// トーラス構造でのテスト
// 線の装飾や背景はどうするか
// オフセットは機能しているのか（大きなサイズでもきちんと動くのか）
// 各種アイコン、プレイヤーの表示
// あと挙動が若干不自然なのをどう解消するのか
// などなど

// 徘徊オブジェクトの仕様
// どっかの頂点に出現
// どっかの辺に乗る
// 辺から辺へ
// 頂点では基本的にいずれか選んで移動、来た方向以外で。
// 行けない場合に引き返す。
// プレイヤーの移動ルーチンと違ってdirectionが出てこない（選択肢から選ぶだけ）ので楽だと思う
// 移動スピードで個性を出せる感じ
// そこまでできたらなんか出させる。攻撃っぽい何か。
// こちらも攻撃っぽい何かを出せるようにする
// 当たる仕様まで作るならHPとかダメージ量とかも必要になりそう・・

// まず頂点について、ゴールまでの最短ルート上の頂点というのはゴールまで行く場合すべて必ず通ることになってる
// どこを通行不能にしてもたどり着けない
// だからたとえばどっかにカギをおいてそれで扉を開けさせることも可能
// valueについてはvalueが大きいマスはそれよりvalueが小さいマスより先には到達出来ないから
// 最短ルート上のどっかのマスを不能にしてそこを開けるカギをそれよりvalueの小さいマスにランダムに置いてもまったく問題ない
// ただたいていの場合ルート上に置かれちゃうのがまずいところ（まあそれは仕方ないのだけど・・）
// フラグでonRoute=true/falseでonRouteでかつvalueがgoalの1割～9割のマスにフラッグを置きたいのよね.
// オリエンテーリングでよくあるあれ
// スタートは赤フラッグ（文字S）、ゴールは紫フラッグ（文字G）
// やめ
// 32x32をくるくる、でいいのでは。
// 四角形に(32,0)→(0,32)の線を引いてその下が色で上が文字。裏は灰色、これがくるくるする。OK!
// 同時にふんわり浮かせる（やや高めの所をsinで小さくふわふわ）
// って思ったけどよく考えたらonRouteに置いちゃったらヒントになってしまうので
// まあ別にいいか
// onRouteの1割~9割に置く！
// 3%～7%の頂点からランダムチョイスしてどっかにカギ置いてそれ取らないと空かないようにしたら面白そう
// いいや・・・はやくフラッグ置こう

// onRouteできました(疲れた・・・）
// フラッグ立てたよ。立てたけど・・onRoute要らんやんな・・
// なんかの役には立つだろうから残しといて（（（

// オブジェクトがへんなとこ移動してる
// どうもフロアの切り替えで失敗してるっぽい→直した

// 次は
// まあゆくゆくはポイント初めて通過した時の効果音とかゴール着いたら次のステージとかそもそもステージ選択とか
// いろいろ斜めの辺とかもあるけど作りたいけど
// また今度ね

// プレイヤーがどこにいるのかわかりにくいからなんか周囲を円がくるくるまわるとかでわかりやすくしてビジュアルはかわいいのお願い
// 攻撃はマウスダウンからリリースまでの時間で3種類（マウスの方向に1発、マウスの方向含めて4方向に1発ずつ、マウスの方向にレーザー1発）
// レーザーはスリップダメージだけどほかの弾丸は当たると消える
// ライフゲージを表示してわかりやすく（プレイヤーも）敵は赤でこっちは青
// そんな感じ
// 弾丸は個別にクラス用意して

// 考えた。
// まずスペースクラス
// これには640x480（表示エリア）と迷路のサイズ（w*GRIDxh*GRID的なやつ！）が入ってて
// これを表示するオブジェクトに持たせる
// これを使って自前でオフセットを計算する感じ
// で、その中にプレイヤーの存在フロアの情報も入ってるわけね
// それを参照して描画するかどうか決めるわけ
// それをやったうえでプレイヤー・・のビジュアルはおいといて、周囲を3つくらい楕円用意してそのまわりに赤青緑の円をまわす
// 楕円軌道だけ。・・地味だからキューブ回そうかな・・
// 能力強化でキューブ増やす（4つまで）
// 攻撃はクリックからリリースまでの・・表現方法はおいおい考える、あのあれ、プレイヤーがどこにいるのかわかりづらいっていうね。
// それをなんとかしないと、スタートの段階でつまづいちゃうので。
// リリースまでの時間で3段階。
// レベル1:カーソルの方向に直進弾。グレードアップで一度に出る弾の数とダメージと弾の大きさが上がる
// 直進弾でスピードは一定
// レベル2:いわゆる3WAYで、同じ方向に3つ並んで発射される感じ。
// 挙動はゆっくりからのぎゅーんって感じで途中から一定スピード
// 弾の形状は矢のようで当たり判定は線分で取る。矢の頭があたるとダメージ大きいけど柄でもダメージ。
// レベルが上がると大きさと本数とダメージが以下略。
// レベル3:レーザー。マウス方向に距離無限大の帯が出現しゆっくり最大幅まで広がってから幅が短くなって消える。
// マウスを動かすとその間常に帯が移動するすぐれもの
// レベルが上がるとダメージや帯の太さや効果時間が上がる感じですかね
// できるの？？？？
// とりあえずホーミングは考えなくていいです

// トレジャーについて
// 次数を用意する（辺の数）
// onRouteでない頂点で次数1でなおかつonRouteの頂点からの距離（戻す処理を何回やるとonRouteにたどり着くか、
// たどり着いた先のonRouteの頂点のvalueと比べて差を取ればいい感じだけどよく考えたらその回数で出るか）
// まあいいや。で、その値。jsのsortを使う。比較関数で(a,b)=>a.x-b.xってやるとプロパティxを見てそれが
// 小さい順に並ぶ、逆にすると大きい順。だからindexとその値のペアを作って・・
// 逐次更新の方が速いですね・・配列作るのは普通に手間だ、やめよう・・・
// onRouteならスルー、次数2以上ならスルー、次数1でonRouteでなければ処理をやってonRouteまで行く、その際の
// 回数を数えて大きければthis.treasureを更新する、って感じですかね。

// あーーーーむずい。どうしようかね
// いったん、パス。

// 空間情報（オフセットの計算に使う）
/*
class Space{
  constructor(dw, dh){
    this.displaySize = {w:dw, h:dh};
    this.floorSize = {};
    this.currentFloorIndex = 0;
    this.playerPos = undefined; // playerのpositionがオブジェクトなのでそこへのポインタを渡しておく
    this.offSet = {}; // オフセット
  }
  setPlayerPos(_playerPos){
    this.playerPos = _playerPos;
  }
  setFloorSize(fw, fh){
    this.floorSize.w = fw;
    this.floorSize.h = fh;
  }
  setCurrentFloorIndex(){
    this.currentFloorIndex = this.playerPos.z;
  }
  getCurrentFloorIndex(){
    return this.currentFloorIndex;
  }
  setOffSet(){
    this.offSet.x = constrain(this.playerPos.x * GRID - this.displaySize.w * 0.5, 0, this.floorSize.w - this.displaySize.w);
    this.offSet.y = constrain(this.playerPos.y * GRID - this.displaySize.h * 0.5, 0, this.floorSize.h - this.displaySize.h);
  }
  getOffSet(){
    return this.offSet;
  }
  getDrawPos(p){
    // pは描画するそれのポジション。
    // p.zとplayerPos.zを比較すればいろいろわかっちゃうね・・となるとあそこの処理不要だな。
    // って思ったけどそれないと選べないしキャンバスが。
    if(p.z !== this.playerPos.z){ return undefined; }
    return {x:p.x * GRID - this.offSet.x, y:p.y * GRID - this.offSet.y};
  }
  update(){
    this.setCurrentFloorIndex();
    this.setOffSet();
  }
}
*/

// クラス化してそっちにオフセットもろもろ計算させようとしてたけど却下
// まあオフセットの計算だけならいいんだろうけどね・・
// 一瞬スパゲティになりかけたので戻ってきた
// やばいやばい
// そもそも敵を倒す必要あるの？操作性とかいまいちでイライラしそう。
// いっそ今のまま普通にゴール目指すだけ・・だと面白くないよねぇ。

// 普通にゴール目指すだけでいいよもう

// 迷路の種類増やす
// 攻撃とか敵とかはとりあえずいいとして
// なんかいろいろ攻撃かわして

// 迷路はもういいからSTGに戻りたいかも
// ていうか攻撃で敵倒そうみたいなこと考えちゃうのSTG作りたいから
// だったら堂々とSTGでやればいい
// こっちでやる必要ない
// こっちではギミックかわしながらゴールにたどり着く、でいい
// クリックでキャラクターがジャンプしてとげをかわすとか攻撃よけるとかそういうの
// せっかく敵らしきなにかが動くようになったのにもったいない気もするんだけどね
// 出現場所をランダムでなくフラッグの位置にして、そうすればすぐにぶつからないから、あれをジャンプでかわす？クリックジャンプで？
// あれがかわすべきギミックで？あーなる・・そういうのもありね。
// それと別に砲台かなんか（経路の外に置く）から火の玉かなんかだすとか。

// キャラクターのイメージは暫定的に伸縮する長方形でいいと思う。角を丸くしたmicrobe的な。今んとこあれしかできないので。
// その輪郭でまんじゅうはめて目をつけたり耳をつけたりっていうのを考えてる。
// それか方眼紙に描いて32x32で描いてやるのもありかも

// GRIDを可変にすること
// 32を最小サイズにする
// 32より大きくなる可能性を考える
// フラッグの大きさは32で固定して
// 迷路情報作るときにGRIDの情報を添える
// そうすればたとえば32xsqrt(2)とかもできるはず
// もしくは32にしたうえで別の所をいじってもいいけどめんどくさいでしょ？

// 時間ないのでアイデアだけ
/*
スパボン5でクリアする際に潜り抜けるゴールによって
行先が変わるっていうのあったでしょ
トレジャーに相当する頂点をゴール扱いにして
そこを通ることでその先の迷路の形状がへんかするとか
したら面白そう
パターンチェンジ
それやらないと延々と同じ形状の迷路が続くだけ
っていう話
*/

んーとね。
20x15を最小サイズとしてね・・・その向こうにエリアが存在する場合に、それを表示することで、
スクロールしないようにしようみたいなね。それを今考えてるんだけど計算がめんどくさすぎて萎えてる。。。。
移動に関しては問題ないのです・・その向こうのエリアをプレイヤーの存在する位置から計算するのが大変っていう。

クリックするとジャンプフラグが立って32フレームの間宙に浮く感じで（およそ0.5秒）
その間はダメージを受けないのでとげをかわせる感じ
体ひとつぶん浮く感じでおねがい

その間はp.yが減らされる・・
jumpFlagが出ているときに接触しても・・んー。障害物のグラフィック
例のなんか曲線アートみたいのをくるくるまわ・・
ていうかこれも3Dでなんか作っちゃうとか？
プレイヤーを中心とする640x480に触れるエリアをすべて描画するって感じ
で、それぞれのオフセットと描画範囲を正確に計算する感じ


まずあれ
基本サイズを決めてその中で展開されるみたいな
えーと・・・変更点がいろいろ
たとえば640x480を基本とする場合、これを・・・20x15を最小サイズとしてそれを縦横につなげると。
つまり今までフロアとして扱っていたものをそれぞれ同じサイズに、まあ同じサイズだったけど、
今考えたけどひし形や六角形だとむずいや
上下左右だけ表示されるようにする感じ。
いける？
やめよう
今やりたいのは隣のエリアに行けるときの先が見えない問題をどうにかしようっていうのだからそこどうにかできないとどうしようも
ないので
上下左右だけ！！！
ひし形ならぎりぎりいける。正六角形は辺の向こう側全体で周囲が構成されてしまうので・・螺旋階段作れない
とりあえず20x15でいいです

正方形を基本サイズにしてぐるぐる繋げたら面白そう（実装が鬼）

まず20x15をいくつか用意する
辺のつながりを作る
それにより接続される
接続先は自分自身でもOK（トーラス構造）
新しくその、0,1,2,3で方向をid化したうえで、その方向に何があるのか書いておいて、
プレイヤーがいるエリアの上下左右に部屋があればそれを描画する感じ。スクロールも考慮する。
エリアと同じ枚数のグラフィックを新たに用意する
敵やプレイヤーはそれらに毎フレーム描画する感じですね
んでseparate辺上にいる場合は両方に描画する
これでいいはず

んー今考えてるのは逆に貼り付けるというかそんな感じのあれ
その場合は逆につけますっていうのを・・たとえば4,5,6,7で0,1,2,3の上下反転みたいな？左右反転も？
その場合はグラフィックも左右や上下を反転させたうえで描画しボードに落とすときにも同じように反転させてくっつける感じね
そういうのも面白そうなので考えたりしてる
上下反転、左右反転、180°の回転の4パターンのはりつけの組み合わせとかする感じ
エリアをクラス化してグラフィックとは別に接続状況をidで指示できるようにする
ステージ構成の際にそれを用意して
同じフォーマットなら再利用
違うフォーマットなら破棄して再構成する感じ

クラス、とりあえず640x480のボードとつなぎ方だけでいいですね
ていうかグラフィック再利用できるから
たとえば最初に20枚くらい作っておいて
それ使いまわせばいいやね破棄する必要はない
迷路のグラフィック作成時に
そこに・・

というわけで今floorArrayってなってるとこをareasにする
Areaが20個
んでそれと別に5枚（プレイヤーのエリアと上下左右の合計5枚）
毎フレームの描画はそこにやる
もしかしたらエリアのプロパティを追加して背景色とか具体的な背景指定するかもだけど

// 上下左右でいいんじゃないかな
// 多分だけど
// つまりね、例えばエリアの枚数を32上限として、（32個も用意するの！？しないけど）16でいいです。
// 左右反転の場合は+32,上下反転の場合は+64,上下左右反転の場合は+96ってやれば、
// 32,64のビットを見るだけでそれがどういう風に反転してるかわかる・・
// 31と&取ればフロア数が出るし。
// クラインの四元群だから相対的だし。そういう感じで。

// 16枚で。
// +16:左右反転、+32:上下反転、+48:上下左右反転
// それぞれのエリアに0,1,2,3方向に何があるのか指定しておく
// 何もない場合は-1
// 自分を指定するのもあり(フロア1枚ですべて0とかもありってこと)
// そして各エリアに対しその向こう側のエリアとの接続を行う感じ
// 重複を防ぐためidの小さい方から大きい方のみ行う
// 同じ場合も行う（当然）
// つまりこっちのidが向こうより大きい場合のみスルーするわけね
// それが終わったらいつものようにデータ送信
// そのうえでAreaクラスに情報をいろいろ登録
// 迷路を作り終わったらAreaクラスにベースを描画（暗い灰色で）
// 準備完了
// 毎フレームの処理
// プレイヤー、敵、フラッグそれぞれについて存在するフロアを確認
// バーテックスの場合はいいけど辺の場合はまたがっていれば両方で描画する感じで
// さてさて
// プレイヤーの存在するエリアとその上下左右のエリアがあればそれら、つまり1～5枚
// これらにまずベースの辺を描画
// （なおベースはプレイヤーが乗った辺の色が随時白で更新されていく）
// 次に敵とかフラッグとかが・・
// ちなみにプレイヤーの存在するって言ったけどseparateの場合はprogressをきちんと見て0.5より大きい小さいとか
// きちんと見るのでよろしく
// 特に問題起きないと思うけど
// そうして描画が確定したらそれら一つ一つに描画していく・・
// 反転が起こっている場合は辺の描画の際に反転が起きているのでそれ含めて考慮しつつ
// 敵やら何やらもそれ含めて反転描画する感じですね
// まあすぐには実装しないけど
// プレイヤー自身の存在するエリアが反転起きてる場合それを考慮してひっくり返したりするのでそれ含めて・・ね。
// 正方形の方が自由度高そうでいいな・・そのうちやってみたい。（今やろうよ）
// 自由度が高いとその分大変なので今はやりません（やりません）
// 最後にそれら最大5つを適切にオフセット考慮しつつコラージュして完成。


// mazeConnectingでハマってる
/*
// dirで場合分け。
// dirが0のときはiの右とkの左、dirが1のときはiの下とkの上、dirが2のときはiの左とkの右、dirが3のときはiの上とkの下を
// つなげる
// separateは同じフロアであってももちろんすべてtrueとする感じで
// 同じフロアのトーラス構造であっても・・・んー。一枚に両方・・
// まあそんなことは、起きるね。どうしようね。
// あるオブジェクトをあるフロアに描画するとき、その上下左右に自分と同じフロアがある場合は
// たとえば下に同じフロアがあるとすると当然上にもそのフロアがあるわけ。右なら左。
// だからその場合は
// ていうか辺ベースで描画する？個別の位置ベースじゃなくて。
// つまり存在する辺の情報とプログレス情報を使って描画するようにする
// そうすれば同じフロアの上下左右をつなげる場合でも
// 同じ・・あー、ちがうちがう！
// 頂点ベースで描画する。つまり、辺の両端の頂点を見て、それらの頂点が属する位置ごとに描画する
// separateでない場合は1回しか描画しなくていい
// 同じフロアでseparateの場合はそれぞれの頂点ごとに同じフロアマップに2つ描画する
// 違うフロアでseparateの場合もそれぞれの頂点ごとに違うフロアマップに1つずつ描画する
// 頂点の位置と辺の出てる方向とprogressからフロアごとの描画位置が算出される
// だから各オブジェクトには・・あーそうか、描画オブジェクトには
*/

// 10x8でやるか・・・？
// 10x8でMAX32フロアでやります。つまり最終的には160xやりません
// やりませんが。。
// 40x32だから80x32くらいで最大？64の方がいいかな。10x8が64個。80x64が最大サイズということになるわね。
// 10x8でグリッドサイズ64だから640x512って感じになるね。
// 大幅に書き換えないとだ・・・・でもスライム大きくなるし。わくわく！

// 640x480を640x512にしてGRIDをすべて64にするだけ
// 文字列で書いてあるので変更点は少ないです（よかった・・）
// というわけで帰ったら作業です・・がんば！！！

// このあとやること
// 接続はもう出来てるので今のままあれをあれすると画面が切り替わっちゃう
// とりあえずそれで。
// 接続がうまくいってることを確認したらいよいよグローバルスクロールの実装にとりかかる
// といっても難しくないけどね・・

// むずかしいよ

// 描画順：プレイヤー、敵、その他、最後にフラッグ。そんな感じ。
